#!/usr/bin/env node\n/**\n * Claude Flow v3.0 - Hive-Mind System Tests\n * Comprehensive testing suite for the new AI system\n * No fallback mode testing - only true AI capabilities\n */\n\nconst HiveMindEngine = require('../core/hive-mind-engine');\nconst HiveMindOrchestrator = require('../core/hive-mind-orchestrator');\nconst MemoryManager = require('../core/memory-manager');\nconst ClaudeFlowMain = require('../core/claude-flow-main');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst winston = require('winston');\n\n// Test logger\nconst logger = winston.createLogger({\n    level: 'info',\n    format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.colorize(),\n        winston.format.printf(({ timestamp, level, message }) => {\n            return `${timestamp} [TEST] ${level}: ${message}`;\n        })\n    ),\n    transports: [\n        new winston.transports.Console(),\n        new winston.transports.File({ filename: 'logs/hive-mind-tests.log' })\n    ]\n});\n\nclass HiveMindTestSuite {\n    constructor() {\n        this.testResults = [];\n        this.failedTests = [];\n        this.passedTests = [];\n        \n        // Test configuration\n        this.testConfig = {\n            cleanup: true,\n            verbose: true,\n            mockGitHub: true,\n            testMemoryPath: path.join(process.cwd(), 'test-memory')\n        };\n        \n        logger.info('🧪 Hive-Mind Test Suite v3.0 initialized');\n    }\n    \n    async runAllTests() {\n        logger.info('🚀 Starting comprehensive Hive-Mind system tests...');\n        const startTime = Date.now();\n        \n        try {\n            // Setup test environment\n            await this.setupTestEnvironment();\n            \n            // Core component tests\n            await this.testMemoryManager();\n            await this.testHiveMindEngine();\n            await this.testHiveMindOrchestrator();\n            await this.testClaudeFlowMain();\n            \n            // Integration tests\n            await this.testSystemIntegration();\n            await this.testErrorHandling();\n            await this.testPerformance();\n            \n            // Cleanup\n            if (this.testConfig.cleanup) {\n                await this.cleanupTestEnvironment();\n            }\n            \n            const duration = Date.now() - startTime;\n            await this.generateTestReport(duration);\n            \n        } catch (error) {\n            logger.error('Test suite failed:', error.message);\n            throw error;\n        }\n    }\n    \n    async setupTestEnvironment() {\n        logger.info('🔧 Setting up test environment...');\n        \n        // Create test directories\n        fs.ensureDirSync('logs');\n        fs.ensureDirSync(this.testConfig.testMemoryPath);\n        \n        // Mock environment variables for testing\n        process.env.GITHUB_TOKEN = 'test-token-mock';\n        process.env.REPOSITORY = 'test-owner/test-repo';\n        process.env.AUTO_CREATE_PR = 'false'; // Disable PR creation in tests\n        process.env.LEARNING_ENABLED = 'true';\n        \n        logger.info('✅ Test environment setup completed');\n    }\n    \n    async cleanupTestEnvironment() {\n        logger.info('🧹 Cleaning up test environment...');\n        \n        try {\n            // Remove test memory directory\n            if (fs.existsSync(this.testConfig.testMemoryPath)) {\n                fs.removeSync(this.testConfig.testMemoryPath);\n            }\n            \n            // Clean up any test files\n            const testFiles = [\n                'claude-flow-results.json',\n                'claude-flow-error.json',\n                'test-results.json'\n            ];\n            \n            testFiles.forEach(file => {\n                if (fs.existsSync(file)) {\n                    fs.unlinkSync(file);\n                }\n            });\n            \n        } catch (error) {\n            logger.warn('Cleanup warning:', error.message);\n        }\n        \n        logger.info('✅ Test environment cleanup completed');\n    }\n    \n    // =================================================================\n    // MEMORY MANAGER TESTS\n    // =================================================================\n    \n    async testMemoryManager() {\n        logger.info('🧠 Testing Memory Manager...');\n        \n        const memoryManager = new MemoryManager({\n            memoryPath: this.testConfig.testMemoryPath,\n            backupEnabled: false // Disable backups in tests\n        });\n        \n        // Test pattern storage\n        await this.runTest('Memory Manager - Pattern Storage', async () => {\n            const testPattern = {\n                type: 'test-pattern',\n                signature: {\n                    domain: 'testing',\n                    complexity: 'low',\n                    category: 'unit-test'\n                },\n                successRate: 0.95,\n                confidence: 0.9\n            };\n            \n            const patternId = await memoryManager.storePattern(testPattern);\n            const retrievedPattern = await memoryManager.getPattern(patternId);\n            \n            if (!retrievedPattern || retrievedPattern.type !== 'test-pattern') {\n                throw new Error('Pattern storage/retrieval failed');\n            }\n            \n            return { patternId, pattern: retrievedPattern };\n        });\n        \n        // Test knowledge storage\n        await this.runTest('Memory Manager - Knowledge Storage', async () => {\n            const testKnowledge = {\n                domain: 'testing',\n                category: 'unit-test',\n                pattern: 'test-knowledge-pattern',\n                effectiveness: 0.85,\n                tags: ['testing', 'memory', 'storage']\n            };\n            \n            const knowledgeId = await memoryManager.storeKnowledge(testKnowledge);\n            const retrievedKnowledge = await memoryManager.getKnowledge(knowledgeId);\n            \n            if (!retrievedKnowledge || retrievedKnowledge.domain !== 'testing') {\n                throw new Error('Knowledge storage/retrieval failed');\n            }\n            \n            return { knowledgeId, knowledge: retrievedKnowledge };\n        });\n        \n        // Test search functionality\n        await this.runTest('Memory Manager - Search Functionality', async () => {\n            const patterns = await memoryManager.findPatterns({\n                domain: 'testing',\n                minConfidence: 0.8\n            });\n            \n            const knowledge = await memoryManager.findKnowledge({\n                domain: 'testing',\n                tags: ['testing']\n            });\n            \n            if (patterns.length === 0 || knowledge.length === 0) {\n                throw new Error('Search functionality failed');\n            }\n            \n            return { patterns: patterns.length, knowledge: knowledge.length };\n        });\n        \n        logger.info('✅ Memory Manager tests completed');\n    }\n    \n    // =================================================================\n    // HIVE-MIND ENGINE TESTS\n    // =================================================================\n    \n    async testHiveMindEngine() {\n        logger.info('🐝 Testing Hive-Mind Engine...');\n        \n        const engine = new HiveMindEngine({\n            maxAgents: 5,\n            maxResolutionTime: 60000, // 1 minute for tests\n            learningEnabled: true\n        });\n        \n        // Test issue analysis\n        await this.runTest('Hive-Mind Engine - Issue Analysis', async () => {\n            const mockIssue = {\n                number: 123,\n                title: 'Test bug in authentication system',\n                body: 'The login function throws an error when invalid credentials are provided. This is a critical security issue that needs immediate attention.',\n                labels: [{ name: 'bug' }, { name: 'security' }]\n            };\n            \n            const session = {\n                id: 'test-session-1',\n                issue: mockIssue,\n                startTime: Date.now(),\n                status: 'analyzing',\n                agents: new Map(),\n                solutions: [],\n                patterns: [],\n                metrics: {\n                    agentsSpawned: 0,\n                    patternsRecognized: 0,\n                    solutionsGenerated: 0,\n                    qualityScore: 0\n                }\n            };\n            \n            const analysis = await engine.performDeepAnalysis(session);\n            \n            if (!analysis || !analysis.semantic || !analysis.complexity) {\n                throw new Error('Issue analysis failed');\n            }\n            \n            if (analysis.neuralClassification.category !== 'bug' && analysis.neuralClassification.category !== 'security') {\n                throw new Error('Neural classification failed');\n            }\n            \n            return {\n                category: analysis.neuralClassification.category,\n                confidence: analysis.neuralClassification.confidence,\n                complexity: analysis.complexity.level,\n                domain: analysis.domain\n            };\n        });\n        \n        // Test agent strategy generation\n        await this.runTest('Hive-Mind Engine - Agent Strategy', async () => {\n            const mockAnalysis = {\n                complexity: { level: 'medium', recommendedAgents: 4 },\n                domain: 'security',\n                patterns: [],\n                neuralClassification: { category: 'bug', confidence: 85 }\n            };\n            \n            const session = { id: 'test-session-2', analysis: mockAnalysis };\n            const strategy = await engine.generateAgentStrategy(session, mockAnalysis);\n            \n            if (!strategy || !strategy.agents || strategy.agents.length === 0) {\n                throw new Error('Agent strategy generation failed');\n            }\n            \n            if (strategy.agents.length > 5) { // maxAgents = 5\n                throw new Error('Agent count exceeds maximum');\n            }\n            \n            return {\n                agentCount: strategy.agents.length,\n                coordination: strategy.coordination,\n                expectedSynergy: strategy.expectedSynergy\n            };\n        });\n        \n        // Test system status\n        await this.runTest('Hive-Mind Engine - System Status', async () => {\n            const status = engine.getSystemStatus();\n            \n            if (!status || status.engine !== 'hive-mind-v3') {\n                throw new Error('System status failed');\n            }\n            \n            return status;\n        });\n        \n        logger.info('✅ Hive-Mind Engine tests completed');\n    }\n    \n    // =================================================================\n    // HIVE-MIND ORCHESTRATOR TESTS\n    // =================================================================\n    \n    async testHiveMindOrchestrator() {\n        logger.info('🎯 Testing Hive-Mind Orchestrator...');\n        \n        // Mock GitHub for testing\n        const mockOrchestrator = {\n            githubToken: 'test-token',\n            repository: 'test-owner/test-repo',\n            autoCreatePR: false,\n            learningEnabled: true\n        };\n        \n        // Test configuration validation\n        await this.runTest('Hive-Mind Orchestrator - Configuration', async () => {\n            try {\n                // This should work with proper config\n                const orchestrator = new HiveMindOrchestrator(mockOrchestrator);\n                const status = orchestrator.getStatus();\n                \n                if (!status || status.system !== 'hive-mind-orchestrator-v3') {\n                    throw new Error('Orchestrator configuration failed');\n                }\n                \n                return status;\n            } catch (error) {\n                throw new Error(`Configuration validation failed: ${error.message}`);\n            }\n        });\n        \n        // Test status reporting\n        await this.runTest('Hive-Mind Orchestrator - Status Reporting', async () => {\n            const orchestrator = new HiveMindOrchestrator(mockOrchestrator);\n            const status = orchestrator.getStatus();\n            \n            const requiredFields = ['system', 'status', 'sessions', 'configuration'];\n            \n            for (const field of requiredFields) {\n                if (!status.hasOwnProperty(field)) {\n                    throw new Error(`Missing status field: ${field}`);\n                }\n            }\n            \n            return status;\n        });\n        \n        logger.info('✅ Hive-Mind Orchestrator tests completed');\n    }\n    \n    // =================================================================\n    // CLAUDE FLOW MAIN TESTS\n    // =================================================================\n    \n    async testClaudeFlowMain() {\n        logger.info('🚀 Testing Claude Flow Main...');\n        \n        // Test environment validation\n        await this.runTest('Claude Flow Main - Environment Validation', async () => {\n            try {\n                const main = new ClaudeFlowMain();\n                const status = await main.getStatus();\n                \n                if (!status || status.system !== 'claude-flow-v3-main') {\n                    throw new Error('Main system initialization failed');\n                }\n                \n                return status;\n            } catch (error) {\n                throw new Error(`Environment validation failed: ${error.message}`);\n            }\n        });\n        \n        // Test argument parsing\n        await this.runTest('Claude Flow Main - Argument Parsing', async () => {\n            const main = new ClaudeFlowMain();\n            \n            // Mock command line arguments\n            const originalArgv = process.argv;\n            process.argv = [\n                'node',\n                'claude-flow-main.js',\n                '--issue-number=123',\n                '--issue-title=Test Issue',\n                '--priority=high'\n            ];\n            \n            const args = main.parseArguments();\n            \n            // Restore original argv\n            process.argv = originalArgv;\n            \n            if (args.issueNumber !== 123 || args.priority !== 'high') {\n                throw new Error('Argument parsing failed');\n            }\n            \n            return args;\n        });\n        \n        logger.info('✅ Claude Flow Main tests completed');\n    }\n    \n    // =================================================================\n    // INTEGRATION TESTS\n    // =================================================================\n    \n    async testSystemIntegration() {\n        logger.info('🔗 Testing System Integration...');\n        \n        // Test component communication\n        await this.runTest('System Integration - Component Communication', async () => {\n            const memoryManager = new MemoryManager({\n                memoryPath: this.testConfig.testMemoryPath,\n                backupEnabled: false\n            });\n            \n            const engine = new HiveMindEngine({\n                maxAgents: 3,\n                maxResolutionTime: 30000,\n                learningEnabled: true\n            });\n            \n            // Test that engine can work with memory manager\n            const testPattern = {\n                type: 'integration-test',\n                signature: { domain: 'integration', complexity: 'low' },\n                confidence: 0.8\n            };\n            \n            const patternId = await memoryManager.storePattern(testPattern);\n            const retrievedPattern = await memoryManager.getPattern(patternId);\n            \n            if (!retrievedPattern) {\n                throw new Error('Component communication failed');\n            }\n            \n            return { success: true, patternId };\n        });\n        \n        // Test error propagation\n        await this.runTest('System Integration - Error Propagation', async () => {\n            const engine = new HiveMindEngine({\n                maxAgents: 3,\n                maxResolutionTime: 1000 // Very short timeout to trigger error\n            });\n            \n            try {\n                // This should handle errors gracefully\n                const mockIssue = {\n                    number: 999,\n                    title: 'Error test issue',\n                    body: 'This is a test for error handling'\n                };\n                \n                // Engine should handle this gracefully even with short timeout\n                const status = engine.getSystemStatus();\n                \n                if (!status) {\n                    throw new Error('Error propagation test failed');\n                }\n                \n                return { errorHandling: 'passed', status };\n            } catch (error) {\n                // This is expected - test that errors are properly handled\n                return { errorHandling: 'passed', errorMessage: error.message };\n            }\n        });\n        \n        logger.info('✅ System Integration tests completed');\n    }\n    \n    // =================================================================\n    // ERROR HANDLING TESTS\n    // =================================================================\n    \n    async testErrorHandling() {\n        logger.info('🛡️ Testing Error Handling...');\n        \n        // Test invalid input handling\n        await this.runTest('Error Handling - Invalid Input', async () => {\n            const engine = new HiveMindEngine();\n            \n            try {\n                // Test with invalid issue data\n                const invalidIssue = {\n                    number: 'not-a-number',\n                    title: null,\n                    body: undefined\n                };\n                \n                // Engine should handle this gracefully\n                const status = engine.getSystemStatus();\n                return { handled: true, status };\n            } catch (error) {\n                return { handled: true, error: error.message };\n            }\n        });\n        \n        // Test memory corruption handling\n        await this.runTest('Error Handling - Memory Corruption', async () => {\n            const memoryManager = new MemoryManager({\n                memoryPath: this.testConfig.testMemoryPath\n            });\n            \n            try {\n                // Try to store invalid data\n                const circularRef = {};\n                circularRef.self = circularRef;\n                \n                // This should be handled gracefully\n                await memoryManager.storePattern({ circular: circularRef });\n                \n                return { handled: true };\n            } catch (error) {\n                // Expected - circular references should be caught\n                return { handled: true, caught: error.message };\n            }\n        });\n        \n        logger.info('✅ Error Handling tests completed');\n    }\n    \n    // =================================================================\n    // PERFORMANCE TESTS\n    // =================================================================\n    \n    async testPerformance() {\n        logger.info('⚡ Testing Performance...');\n        \n        // Test memory manager performance\n        await this.runTest('Performance - Memory Operations', async () => {\n            const memoryManager = new MemoryManager({\n                memoryPath: this.testConfig.testMemoryPath,\n                backupEnabled: false\n            });\n            \n            const startTime = Date.now();\n            const numOperations = 100;\n            \n            // Store multiple patterns quickly\n            for (let i = 0; i < numOperations; i++) {\n                await memoryManager.storePattern({\n                    type: `perf-test-${i}`,\n                    signature: { domain: 'performance', complexity: 'low' },\n                    confidence: Math.random()\n                });\n            }\n            \n            const duration = Date.now() - startTime;\n            const operationsPerSecond = Math.round((numOperations / duration) * 1000);\n            \n            // Should be able to handle at least 10 operations per second\n            if (operationsPerSecond < 10) {\n                throw new Error(`Performance too slow: ${operationsPerSecond} ops/sec`);\n            }\n            \n            return {\n                operations: numOperations,\n                duration: `${duration}ms`,\n                operationsPerSecond\n            };\n        });\n        \n        // Test system startup performance\n        await this.runTest('Performance - System Startup', async () => {\n            const startTime = Date.now();\n            \n            const engine = new HiveMindEngine({\n                maxAgents: 5\n            });\n            \n            const status = engine.getSystemStatus();\n            const duration = Date.now() - startTime;\n            \n            // Startup should be fast (under 1 second)\n            if (duration > 1000) {\n                throw new Error(`Startup too slow: ${duration}ms`);\n            }\n            \n            return {\n                startupTime: `${duration}ms`,\n                status: status.status\n            };\n        });\n        \n        logger.info('✅ Performance tests completed');\n    }\n    \n    // =================================================================\n    // TEST UTILITIES\n    // =================================================================\n    \n    async runTest(testName, testFunction) {\n        const startTime = Date.now();\n        \n        try {\n            logger.info(`🧪 Running: ${testName}`);\n            \n            const result = await testFunction();\n            const duration = Date.now() - startTime;\n            \n            const testResult = {\n                name: testName,\n                status: 'PASSED',\n                duration: `${duration}ms`,\n                result,\n                timestamp: new Date().toISOString()\n            };\n            \n            this.testResults.push(testResult);\n            this.passedTests.push(testResult);\n            \n            logger.info(`✅ PASSED: ${testName} (${duration}ms)`);\n            \n            if (this.testConfig.verbose && result) {\n                logger.info(`📊 Result:`, JSON.stringify(result, null, 2));\n            }\n            \n        } catch (error) {\n            const duration = Date.now() - startTime;\n            \n            const testResult = {\n                name: testName,\n                status: 'FAILED',\n                duration: `${duration}ms`,\n                error: error.message,\n                stack: error.stack,\n                timestamp: new Date().toISOString()\n            };\n            \n            this.testResults.push(testResult);\n            this.failedTests.push(testResult);\n            \n            logger.error(`❌ FAILED: ${testName} (${duration}ms)`);\n            logger.error(`Error: ${error.message}`);\n        }\n    }\n    \n    async generateTestReport(totalDuration) {\n        const report = {\n            summary: {\n                totalTests: this.testResults.length,\n                passed: this.passedTests.length,\n                failed: this.failedTests.length,\n                successRate: `${Math.round((this.passedTests.length / this.testResults.length) * 100)}%`,\n                totalDuration: `${totalDuration}ms`,\n                timestamp: new Date().toISOString()\n            },\n            system: {\n                version: '3.0.0',\n                mode: 'true-ai-no-fallback',\n                node: process.version,\n                platform: process.platform\n            },\n            results: this.testResults,\n            failedTests: this.failedTests\n        };\n        \n        // Write report to file\n        const reportPath = 'test-results.json';\n        fs.writeJsonSync(reportPath, report, { spaces: 2 });\n        \n        // Log summary\n        logger.info('📊 Test Summary:');\n        logger.info(`Total Tests: ${report.summary.totalTests}`);\n        logger.info(`Passed: ${report.summary.passed}`);\n        logger.info(`Failed: ${report.summary.failed}`);\n        logger.info(`Success Rate: ${report.summary.successRate}`);\n        logger.info(`Total Duration: ${report.summary.totalDuration}`);\n        \n        if (this.failedTests.length > 0) {\n            logger.error('❌ Failed Tests:');\n            this.failedTests.forEach(test => {\n                logger.error(`  - ${test.name}: ${test.error}`);\n            });\n        }\n        \n        logger.info(`📄 Full report saved to: ${reportPath}`);\n        \n        return report;\n    }\n}\n\n// CLI execution\nif (require.main === module) {\n    const testSuite = new HiveMindTestSuite();\n    \n    testSuite.runAllTests()\n        .then(report => {\n            logger.info('🎉 Test suite completed successfully!');\n            \n            if (testSuite.failedTests.length > 0) {\n                logger.error('❌ Some tests failed. Check the report for details.');\n                process.exit(1);\n            } else {\n                logger.info('✅ All tests passed!');\n                process.exit(0);\n            }\n        })\n        .catch(error => {\n            logger.error('💥 Test suite failed:', error.message);\n            logger.error(error.stack);\n            process.exit(1);\n        });\n}\n\nmodule.exports = HiveMindTestSuite;